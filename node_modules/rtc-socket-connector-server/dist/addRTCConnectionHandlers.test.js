"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const socket_io_1 = require("socket.io");
const addRTCConnectionHandlers_1 = require("./addRTCConnectionHandlers");
const socket_io_client_1 = require("socket.io-client");
const PORT = 3010;
describe("addRTCConnectionHandlers", () => {
    test("Client connect to server", (done) => {
        const httpServer = (0, http_1.createServer)();
        const socketServer = new socket_io_1.Server(httpServer);
        (0, addRTCConnectionHandlers_1.addRTCConnectionHandlers)(socketServer, { debug: true });
        httpServer.listen(PORT, () => {
            const clientSocket = (0, socket_io_client_1.io)(`http://localhost:${PORT}`);
            clientSocket.on("connect", () => {
                httpServer.close();
                socketServer.close();
                done();
            });
        });
    });
    describe("Client send message for connecting", () => {
        let httpServer;
        let socketServer;
        let clientSocketA;
        let clientSocketB;
        beforeAll((done) => {
            httpServer = (0, http_1.createServer)();
            socketServer = new socket_io_1.Server(httpServer);
            (0, addRTCConnectionHandlers_1.addRTCConnectionHandlers)(socketServer, { debug: true });
            httpServer.listen(PORT, () => {
                Promise.all([getConnectedClient(), getConnectedClient()]).then(([a, b]) => {
                    clientSocketA = a;
                    clientSocketB = b;
                    done();
                });
            });
        });
        afterAll(() => {
            httpServer.close();
            socketServer.close();
        });
        test("clientA send offer to clientB", (done) => {
            const offer = {
                answerSocketId: clientSocketB.id,
                offerMessage: "offer message from clientA",
            };
            clientSocketB.on("offer", (arg) => {
                expect(arg).toEqual(offer);
                done();
            });
            clientSocketA.emit("offer", offer);
        });
        test("clientA send answer to clientB", (done) => {
            const answer = {
                offerSocketId: clientSocketB.id,
                answerMessage: "answer message from clientB",
            };
            clientSocketB.on("answer", (arg) => {
                expect(arg).toEqual(answer);
                done();
            });
            clientSocketA.emit("answer", answer);
        });
        test("clientA send candidate to clientB", (done) => {
            const candidate = {
                destSocketId: clientSocketB.id,
                candidateMessage: "candidate message from clientA",
            };
            clientSocketB.on("candidate", (arg) => {
                expect(arg).toEqual(candidate);
                done();
            });
            clientSocketA.emit("candidate", candidate);
        });
    });
});
function getConnectedClient() {
    return new Promise((resolve) => {
        const clientSocket = (0, socket_io_client_1.io)(`http://localhost:${PORT}`);
        clientSocket.on("connect", () => {
            resolve(clientSocket);
        });
    });
}
